\section{Discussions}
\label{sec:discussion}

\noindent \textbf{IdP-RP collusive attacks.} 
This work prefers to provide better user experience rather than prevent IdP-RP collusive attacks.
Even when the IdP strictly follows the protocols but shares information with RPs,
    a user would complete her logins \emph{entirely} with colluding entities,
    and then the IdP and RPs could always link a user's (pseudo-)identities and accounts (i.e., both IdP untraceability and RP unlinkability are broken),
    unless a secret, unknown to the colluding IdP and RPs,
                is introduced to mask the relationship among the (pseudo-)identities and accounts.
That is, regardless of which $\mathcal{F}_{Acct\ast}()$ is adopted to determine
$Acct_{i,j} = \mathcal{F}_{Acct\ast}(ID_{U_i}, ID_{RP_j})$,
the IdP could always collude with RPs to track a user's login activities by analyzing the relationship between the user's identity and accounts derived at the RPs,
unless $Acct_{i,j} = \mathcal{F}_{Acct\ast}(s_i,ID_{U_i}, ID_{RP_j})$ is adopted and $s_i$ is a long-term secret known to only the user.
In this case,
    a user needs to install a browser extension 
            to maintain the secret,
             and privacy-preserving identity federation \cite{ELPASSO, UnlimitID, idemix, PseudoID, uprov} prefers stronger privacy than user experience.
If this secret is lost or leaked, the user has to notify all RPs to update her accounts derived from this secret %, or additional revocation checking will be needed 
\cite{ELPASSO, UnlimitID}.\footnote{This user-maintained secret used to derive accounts (or mask the relationship of identities and accounts) is different from the credential for user
authentication to the IdP: If the credential is lost or leaked, the user only needs to update it at the IdP and her accounts are kept unchanged.}
Moreover, if the user accesses the services from different devices,
    addition operations are required to synchronize the secret among these devices.

Alternatively, MISO \cite{miso} introduces an extra fully-trusted mixer server other than the IdP to keep $s_i$,
            to calculate user pseudo-identities (or accounts) in each login.
Then, in MISO the mixer server can track all users' login activities,
    but the IdP cannot even when colluding with RPs.

On the contrary,
    UPPRESSO is designed to provide privacy-preserving SSO services accessed from COTS browsers without extra trusted servers,
        at the cost of user privacy vulnerable to IdP-RP collusive attacks.
Our strategy offers an option for different users.
In the future, we plan to improve the identity-transformation algorithms
    to process such a user secret as optional arguments,
    and then flexible privacy-preserving services will be provided.

%UPPRESSO assumes an honest IdP, and the user-i script downloaded from IdP servers is also honest; otherwise, it might directly disclose the identities of visited RPs to the IdP.

%Besides, as its functions are predetermined,
% this script may be checked using subresource integrity (SRI) \cite{sri},
%        by the RP window within a browser.


%\vspace{0.75mm}
%\noindent \textbf{Applicability of identity transformations.}
%The proposed identity-transformation algorithms %i.e., $\mathcal{F}_{PID_{RP}}()$, $\mathcal{F}_{PID_U}()$, and $\mathcal{F}_{Acct}()$,
%can be applied to a wide range of SSO scenarios, including web applications, mobile Apps, and native software.
%These algorithms follow the common model of popular SSO protocols and do not depend on any specific implementations.

%\vspace{0.75mm}
\noindent \textbf{Support for the authorization code flow.} In the authorization code flow of OIDC \cite{OpenIDConnect}, the IdP does not directly return identity tokens.
Instead, it generates an authorization code, which is forwarded to the target RP.
The RP uses this code to retrieve identity tokens from the IdP.

$\mathcal{F}_{Acct\ast}()$, $\mathcal{F}_{PID_{U}}()$, $\mathcal{F}_{PID_{RP}}()$ and $\mathcal{F}_{Acct}()$, can be also integrated into the authorization code flow of OIDC to transform (pseudo-)identities in signed identity tokens.
Then, the user-i script will forward an authorization code (but not the token) to the user-r script, and to the RP finally.
Then, this code serves as an index to retrieve tokens by the RP, not disclosing any information about the user.
On receiving an authorization code, the RP uses it as well as a credential issued by the IdP during the initial registration \cite{OpenIDConnect}, to retrieve identity tokens from the IdP's token endpoint \cite{rfc6749}.

Meanwhile, to hide RP identities from the IdP in the retrieval of identity tokens, privacy-preserving credentials
    %(e.g., ring or group signatures \cite{ring-sig,chaum1991group})
    (e.g., ring signatures \cite{ring-sig} or privacy passes \cite{privacypass,trusttoken})
 and anonymous communications (e.g., oblivious proxies \cite{ohttp-rfc} or Tor \cite{tor}) need to be adopted for RPs.
Otherwise, if the visited RP is not anonymously authenticated to the IdP in the retrieval of tokens,
    IdP untraceability is broken.

%\vspace{0.75mm}
%\noindent \textbf{Scalability.}
%$ID_{RP}$ is generated uniquely during the initial registration of an RP with a capacity of $n$, which is the order of $G$. For the NIST P256 elliptic curve, $n$ is approximately $2^{256}$.
%$PID_{RP}$ is ensured to be unique in unexpired tokens.
%The probability of at least two identical $PID_{RP}$s among $\sigma$ unexpired tokens is $1-\prod_{i=0}^{\sigma-1}(1-i/n)$.
%If the system serves $10^{8}$ requests per second and each token has a validity period of 10 minutes, $\sigma$ is less than $2^{36}$. So the $PID_{RP}$-collision probability is negligible, i.e., less than $2^{-183}$ for the NIST P256 curve.
%
%The maximal amount of accounts at any RP is the same as the capacity of user identities at the IdP.
%At any RP a unique account is automatically assigned to each user because $Acct =  [ID_U]ID_{RP} = [u]ID_{RP}$.
%Finally, stronger elliptic curves accommodate more RPs and users, e.g., $n$ is about $2^{384}$ for the NIST P384 curve.


%\vspace{0.75mm}
\noindent \textbf{Alternatives to generate $\boldsymbol{ID_{RP}}$ and bind $\boldsymbol{ReEnpt_{RP}}$.}
In UPPRESSO the IdP generates random $ID_{RP}$ and signs an RP certificate to bind $ID_{RP}$ and $ReEnpt_{RP}$, which is verified by the user-i script.
This ensures the relationship between the RP designated by an identity token and the URL to receive this token.
It also guarantees that the target RP has already registered itself at the IdP and prevents unregistered RPs from utilizing the IdP's services \cite{OpenIDConnect,save-flow}.

An alternative method for binding $ID_{RP}$ and $ReEnpt_{RP}$ is
 to design a \emph{deterministic} scheme to calculate unique $ID_{RP}$ based on the RP's unambiguous name such as its domain.
This can be achieved by encoding the domain with a hashing-to-elliptic-curves function \cite{irtf-cfrg-hash-to-curve-16}, which provides collision resistance but not revealing the elliptic-curve discrete logarithm of the output. It generates a point on $\mathbb{E}$ as $ID_{RP}$, ensuring the \emph{uniqueness} of $ID_{RP} = [r]G$ while keeping $r$ unknown. %For example, using a hash function $Hs()$ to encode an RP's domain or the RP script's origin, e.g., verb+https://RP.com+)
In this case, in Step 1.2 the user-r script sends only the RP's redirection endpoint (i.e., its URL for receiving tokens) but not its RP certificate, and the user-i script calculates $ID_{RP}$ by itself based on the RP's domain. 
Then, any RP can be visited through the SSO services, either registered or not.

However, if some RP changes its domain, for example, from \verb+https://theRP.com+ to \verb+https://RP.com+, the accounts (i.e., $Acct = [ID_U]ID_{RP}$) will inevitably change.
Thus, a user is required to perform special operations to migrate her account to the updated RP system.
It is worth noting that the user operations cannot be eliminated in the migration to the updated one;
otherwise, it implies two colluding RPs could link a user's accounts across these RPs.


%\vspace{0.75mm}
\noindent \textbf{Restriction of the user-r script's origin.}
The user-i script forwards tokens to the user-r script, and the \verb+postMessage+ targetOrigin mechanism \cite{postm-targeto} restricts the recipient of the forwarded identity tokens, to ensure that the tokens will be sent to the intended $ReEnpt_{RP}$, as specified in the RP certificate. The targetOrigin is specified as a combination of protocol, port (if not present, 80 for \verb+http+ and 443 for \verb+https+), and domain (e.g., \verb+RP.com+).
The user-r script's origin must accurately match the targetOrigin to receive tokens.

The targetOrigin mechanism does not check the whole URL path in $ReEnpt_{RP}$, but introduces no {\em additional} risk.
%This assumes only one RP runs on a domain.
Consider two RPs in one domain but receiving tokens through different URLs,
 e.g., \verb+https://RP.com/honest/tk+ and \verb+https://RP.com/malicious/tk+.
This mechanism cannot distinguish them.
%
% Following the same-origin policy (SOP) \cite{sop} for browser access control, the IdP script sends tokens to both endpoints using \verb+postMessage+.
%
Because a browser controls access to web resources following the same-origin policy (SOP) \cite{sop},
    a user's resources in the honest RP server is accessible to  the malicious server.
 For example, it could steal cookies by \verb+window.open('https://RP.com/honest').+ \verb+document.cookie+,
 even if the honest RP restricts only the HTTP requests to specific paths are allowed to access its cookies.
So this risk is caused by the SOP model of browsers but not our designs,
    and commonly exists in SSO services accessed from COTS browsers \cite{rfc6749,SPRESSO,MITREid,GoogleIdIntegrate,uber}.

%\vspace{0.75mm}

%\noindent \textbf{Quantum resistance.}
%The current designs of UPPRESSO do not achieve quantum resistance.
%In the future, we will investigate alternative algorithms for quantum-secure services.
%We plan to adopt a quantum-resistant public-key algorithm to sign identity tokens and RP certificates,
%    and study quantum-resistant OPRFs \cite{ideal-lattice-oprf,isogency-oprf}
% to investigate if they support collision-free $PID_{RP}$s (i.e., no collision exists in the blinded inputs of evaluated pseudo-random functions; see Appendix \ref{proof-rp-collision}).


%%%%%%%%%%%%%%%%%%%%% 几个方面的扩展
% 1. 解决IdP数据泄露
% 如果IdP的数据库泄露，用户列表u公开，则RP就可以，针对每一个u，计算[u]ID_{RP}；然后，
% 2. 授权码模式
% 可以使用PKCE方式，直接在前端获取。通常，PKCS模式用在没有后端的RP（例如，纯客户端）。
% 对于有后端，可以将​code_verifier传给RP后端？也能够达到目标。
% 3. RP后端访问IdP，需要通过TOR
% 为了不传递RP ID和Secret，可以是：传递PKCE的code_verifier [user将code_verifier传递给RP]，
% 也可以是群签名/环签名之类的。
% 4. 要求RP有授权
% 可以有2种方式：
%   去掉RP Cert；采取授权码方式 + 群签名/环签名之类凭证。
%   去掉RP Cert：采取授权码方式 + PrivacyPass之类匿名凭证（还可以有准确计费）。
% 5. 还有一种方式
% 隐式模式 + PrivacyPass之类匿名凭证（还可以有准确计费）。因为其它方式都需要通过TOR。