\section{Discussions}
\label{sec:discussion}

\noindent \textbf{IdP-RP collusive attacks.} 
This work prefers to provide better user experience rather than prevent IdP-RP collusive attacks.
Even when the IdP strictly follows the protocols but shares information with RPs,
    a user would complete her logins \emph{entirely} with colluding entities,
    and then the IdP and RPs could always link a user's (pseudo-)identities and accounts (i.e., both IdP untraceability and RP unlinkability are broken),
    unless a secret, unknown to the colluding IdP and RPs,
                is introduced to mask the relationship among the (pseudo-)identities and accounts.
That is, regardless of which $\mathcal{F}_{Acct\ast}()$ is adopted to determine
$Acct_{i,j} = \mathcal{F}_{Acct\ast}(ID_{U_i}, ID_{RP_j})$,
the IdP could always collude with RPs to track a user's login activities by analyzing the relationship between the user's identity and accounts derived at the RPs,
unless $Acct_{i,j} = \mathcal{F}_{Acct\ast}(s_i,ID_{U_i}, ID_{RP_j})$ is adopted and $s_i$ is a long-term secret known to only the user.
In this case,
    a user needs to install a browser extension 
            to maintain the secret,
             and privacy-preserving identity federation \cite{ELPASSO, UnlimitID, idemix, PseudoID, uprov} prefers stronger privacy than user experience.
If this secret is lost or leaked, the user has to notify all RPs to update her accounts derived from this secret %, or additional revocation checking will be needed 
\cite{ELPASSO, UnlimitID}.\footnote{This user-maintained secret used to derive accounts (or mask the relationship of identities and accounts) is different from the credential for user
authentication to the IdP: If the credential is lost or leaked, the user only needs to update it at the IdP and her accounts are kept unchanged.}
Moreover, if the user accesses the services from different devices,
    addition operations are required to synchronize the secret among these devices.

Alternatively, MISO \cite{miso} introduces an extra fully-trusted mixer server other than the IdP to keep $s_i$,
            to calculate user pseudo-identities (or accounts) in each login.
Then, in MISO the mixer server can track all users' login activities,
    but the IdP cannot even when colluding with RPs.

On the contrary,
    UPPRESSO is designed to provide privacy-preserving SSO services accessed from COTS browsers without extra trusted servers.
  %      at the cost of user privacy vulnerable to IdP-RP collusive attacks.
Our strategy offers a different option.
In the future, we plan to improve the identity-transformation algorithms
    to process such a user secret as optional arguments,
    and then flexible privacy-preserving services will be provided.
    
   

%UPPRESSO assumes an honest IdP, and the user-i script downloaded from IdP servers is also honest; otherwise, it might directly disclose the identities of visited RPs to the IdP.

%Besides, as its functions are predetermined,
% this script may be checked using subresource integrity (SRI) \cite{sri},
%        by the RP window within a browser.


%\vspace{0.75mm}
%\noindent \textbf{Applicability of identity transformations.}
%The proposed identity-transformation algorithms %i.e., $\mathcal{F}_{PID_{RP}}()$, $\mathcal{F}_{PID_U}()$, and $\mathcal{F}_{Acct}()$,
%can be applied to a wide range of SSO scenarios, including web applications, mobile Apps, and native software.
%These algorithms follow the common model of popular SSO protocols and do not depend on any specific implementations.

%\vspace{0.75mm}
\noindent \textbf{Support for the authorization code flow.} In the authorization code flow of OIDC \cite{OpenIDConnect}, the IdP does not directly return identity tokens.
Instead, it generates an authorization code, which is forwarded to the target RP.
The RP uses this code to retrieve identity tokens from the IdP.

$\mathcal{F}_{Acct\ast}()$, $\mathcal{F}_{PID_{U}}()$, $\mathcal{F}_{PID_{RP}}()$ and $\mathcal{F}_{Acct}()$, can be also integrated into the authorization code flow of OIDC to transform (pseudo-)identities in signed identity tokens.
Then, in the flow an authorization code (but not the token) will be sent to the user-r script, and to the RP finally.
This code serves as an index to retrieve tokens by the RP, not disclosing any information about the user.
On receiving an authorization code, the RP uses it as well as a credential issued by the IdP during the initial registration \cite{OpenIDConnect}, to retrieve identity tokens from the IdP's token endpoint \cite{rfc6749}.

Meanwhile, to hide RP identities from the IdP in the retrieval of identity tokens, privacy-preserving credentials
    %(e.g., ring or group signatures \cite{ring-sig,chaum1991group})
    (e.g., ring signatures \cite{ring-sig} or privacy passes \cite{privacypass,trusttoken})
 and anonymous communications (e.g., oblivious proxies \cite{ohttp-rfc} or Tor \cite{tor}) need to be adopted for RPs.
Otherwise, if the visited RP is not anonymously authenticated to the IdP in the retrieval of tokens,
    IdP untraceability is broken.





%\vspace{0.75mm}
%\noindent \textbf{Scalability.}
%$ID_{RP}$ is generated uniquely during the initial registration of an RP with a capacity of $n$, which is the order of $G$. For the NIST P256 elliptic curve, $n$ is approximately $2^{256}$.
%$PID_{RP}$ is ensured to be unique in unexpired tokens.
%The probability of at least two identical $PID_{RP}$s among $\sigma$ unexpired tokens is $1-\prod_{i=0}^{\sigma-1}(1-i/n)$.
%If the system serves $10^{8}$ requests per second and each token has a validity period of 10 minutes, $\sigma$ is less than $2^{36}$. So the $PID_{RP}$-collision probability is negligible, i.e., less than $2^{-183}$ for the NIST P256 curve.
%
%The maximal amount of accounts at any RP is the same as the capacity of user identities at the IdP.
%At any RP a unique account is automatically assigned to each user because $Acct =  [ID_U]ID_{RP} = [u]ID_{RP}$.
%Finally, stronger elliptic curves accommodate more RPs and users, e.g., $n$ is about $2^{384}$ for the NIST P384 curve.


%\vspace{0.75mm}
\noindent \textbf{Alternatives to generate $\boldsymbol{ID_{RP}}$ and bind $\boldsymbol{ReEnpt_{RP}}$.}
In UPPRESSO the IdP generates random $ID_{RP}$ and signs an RP certificate to bind $ID_{RP}$ and $ReEnpt_{RP}$, which is verified by the user-i script.
This ensures the relationship between the RP designated by an identity token and the URL to receive this token.
It also guarantees that the target RP has already registered itself at the IdP and prevents unregistered RPs from utilizing the IdP's services \cite{OpenIDConnect,save-flow}.

An alternative method for binding $ID_{RP}$ and $ReEnpt_{RP}$ is
 to design a \emph{deterministic} scheme to calculate unique $ID_{RP}$ based on the RP's unambiguous name such as its domain.
This can be achieved by encoding the domain with a hashing-to-elliptic-curves function \cite{irtf-cfrg-hash-to-curve-16}, which provides collision resistance but not revealing the elliptic-curve discrete logarithm of the output. It generates a point on $\mathbb{E}$ as $ID_{RP}$, ensuring the \emph{uniqueness} of $ID_{RP} = [r]G$ while keeping $r$ unknown. %For example, using a hash function $Hs()$ to encode an RP's domain or the RP script's origin, e.g., verb+https://RP.com+)
In this case, in Step 1.2 the user-r script sends only the RP's redirection endpoint (i.e., its URL for receiving tokens) but not its RP certificate, and the user-i script calculates $ID_{RP}$ by itself based on the RP's domain. 
Then, any RP can be visited through the SSO services, either registered or not.

However, if some RP changes its domain, for example, from \verb+https://theRP.com+ to \verb+https://RP.com+, the accounts (i.e., $Acct = [ID_U]ID_{RP}$) will inevitably change.
Thus, a user is required to perform special operations to migrate her account to the updated RP system.
It is worth noting that the user operations cannot be eliminated in the migration to the updated one;
otherwise, it implies two colluding RPs could link a user's accounts across these RPs.


%\vspace{0.75mm}
\noindent \textbf{Restriction of the user-r script's origin.}
The user-i script forwards tokens to the user-r script, and the \verb+postMessage+ targetOrigin mechanism \cite{postm-targeto} restricts the recipient of the forwarded identity tokens, to ensure that the tokens will be sent to the intended $ReEnpt_{RP}$, as specified in the RP certificate. The targetOrigin is specified as a combination of protocol, port (if not present, 80 for \verb+http+ and 443 for \verb+https+), and domain (e.g., \verb+RP.com+).
The user-r script's origin must accurately match the targetOrigin to receive tokens.

The targetOrigin mechanism does not check the whole URL path in $ReEnpt_{RP}$, but introduces no {\em additional} risk.
%This assumes only one RP runs on a domain.
Consider two RPs in one domain but receiving tokens through different URLs,
 e.g., \verb+https://RP.com/honest/tk+ and \verb+https://RP.com/malicious/tk+.
This mechanism cannot distinguish them.
%
% Following the same-origin policy (SOP) \cite{sop} for browser access control, the IdP script sends tokens to both endpoints using \verb+postMessage+.
%
Because a browser controls access to web resources following the same-origin policy (SOP) \cite{sop},
    a user's resources in the honest RP server is accessible to  the malicious server.
 For example, it could steal cookies by \verb+window.open('https://RP.com/honest').+ \verb+document.cookie+,
 even if the honest RP restricts only the HTTP requests to specific paths are allowed to access its cookies.
So this risk is caused by the SOP model of browsers but not our designs,
    and commonly exists in SSO services accessed from COTS browsers \cite{rfc6749,SPRESSO,MITREid,GoogleIdIntegrate,uber}.
    
    
    
\noindent \textbf{Support for the redirect UX login.}    
UPPRESSO can be adapted to support the OIDC login flow with Redirect UX (full-page navigation) instead of the pop-up UX. In the standard OIDC Redirect UX, the Relying Party (RP) and Identity Provider (IdP) typically exchange parameters via HTTP 302 redirections. However, to maintain UPPRESSO's privacy guarantees (i.e., IdP-based login tracing), the flow is modified to ensure the RP’s identity remains hidden from the curious IdP during these navigational hand-offs.

1. Initiating the Login (RP to IdP):
When the user initiates a login, the RP redirects the browser to the IdP. Unlike standard OIDC, which passes the client\_id and redirect\_uri as query parameters, UPPRESSO must pass the RP Certificate ($Cert_{RP}$) and scope as URL fragments (following the \# symbol) . This ensures these sensitive parameters are processed only by the browser and not sent to the IdP’s web server.
Crucially, the RP must also suppress the HTTP Referer header (e.g., using rel="noreferrer") during this redirection. This prevents the IdP server from reading the RP's domain from the HTTP request headers.

2. Authenticating and Returning (IdP to RP):
Same as in pop-up UX, the UPPRESSO client-side script (formerly the user-i script) verifies $Cert_{RP}$, calculates the ephemeral pseudo-identity $PID_{RP}$ locally , and requests the token from the IdP via AJAX/Fetch.
In standard OIDC, the IdP server would issue an HTTP 302 redirect to return the user to the RP. However, in UPPRESSO, the IdP server does not know the RP's redirection endpoint ($ReEnpt_{RP}$) . Therefore, the IdP returns the signed token to the user-i script within the current page. This script then retrieves the valid $ReEnpt_{RP}$ and $t$ from the local session and performs a client-side redirection (e.g., window.location.href) to navigate the user back to the RP with the token in the URL fragment.
This approach ensures that neither the entry redirection nor the return redirection exposes the RP's permanent identity or location to the curious IdP.


%\vspace{0.75mm}

%\noindent \textbf{Quantum resistance.}
%The current designs of UPPRESSO do not achieve quantum resistance.
%In the future, we will investigate alternative algorithms for quantum-secure services.
%We plan to adopt a quantum-resistant public-key algorithm to sign identity tokens and RP certificates,
%    and study quantum-resistant OPRFs \cite{ideal-lattice-oprf,isogency-oprf}
% to investigate if they support collision-free $PID_{RP}$s (i.e., no collision exists in the blinded inputs of evaluated pseudo-random functions; see Appendix \ref{proof-rp-collision}).


%%%%%%%%%%%%%%%%%%%%% 几个方面的扩展
% 1. 解决IdP数据泄露
% 如果IdP的数据库泄露，用户列表u公开，则RP就可以，针对每一个u，计算[u]ID_{RP}；然后，
% 2. 授权码模式
% 可以使用PKCE方式，直接在前端获取。通常，PKCS模式用在没有后端的RP（例如，纯客户端）。
% 对于有后端，可以将​code_verifier传给RP后端？也能够达到目标。
% 3. RP后端访问IdP，需要通过TOR
% 为了不传递RP ID和Secret，可以是：传递PKCE的code_verifier [user将code_verifier传递给RP]，
% 也可以是群签名/环签名之类的。
% 4. 要求RP有授权
% 可以有2种方式：
%   去掉RP Cert；采取授权码方式 + 群签名/环签名之类凭证。
%   去掉RP Cert：采取授权码方式 + PrivacyPass之类匿名凭证（还可以有准确计费）。
% 5. 还有一种方式
% 隐式模式 + PrivacyPass之类匿名凭证（还可以有准确计费）。因为其它方式都需要通过TOR。